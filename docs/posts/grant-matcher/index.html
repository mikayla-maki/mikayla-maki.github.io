<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>The Implications of the Grant Matcher Puzzle | Mikayla&#39;s Project Updates</title>
<meta name="keywords" content="" />
<meta name="description" content="I&rsquo;ve been getting into Object Capabilites recently and it&rsquo;s been immense fun finding people solving all the same problems I&rsquo;ve been thinking about for the last year. One of the more interesting topics is the &lsquo;Grant Matcher&rsquo; puzzle and it&rsquo;s implications for what kinds of cooperation are possible. Here&rsquo;s the original full text of the problem, but I&rsquo;ll be restating it below.
The Phantom Menace First a quick Object Capabilities (OCap) primer, if you know what OCap is just skip to the next section.">
<meta name="author" content="">
<link rel="canonical" href="https://mikayla-maki.github.io/posts/grant-matcher/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css" integrity="sha256-b2AFbUTT9&#43;tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mikayla-maki.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mikayla-maki.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mikayla-maki.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mikayla-maki.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://mikayla-maki.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.2" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="The Implications of the Grant Matcher Puzzle" />
<meta property="og:description" content="I&rsquo;ve been getting into Object Capabilites recently and it&rsquo;s been immense fun finding people solving all the same problems I&rsquo;ve been thinking about for the last year. One of the more interesting topics is the &lsquo;Grant Matcher&rsquo; puzzle and it&rsquo;s implications for what kinds of cooperation are possible. Here&rsquo;s the original full text of the problem, but I&rsquo;ll be restating it below.
The Phantom Menace First a quick Object Capabilities (OCap) primer, if you know what OCap is just skip to the next section." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mikayla-maki.github.io/posts/grant-matcher/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-21T15:15:00-07:00" />
<meta property="article:modified_time" content="2022-08-21T15:15:00-07:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="The Implications of the Grant Matcher Puzzle"/>
<meta name="twitter:description" content="I&rsquo;ve been getting into Object Capabilites recently and it&rsquo;s been immense fun finding people solving all the same problems I&rsquo;ve been thinking about for the last year. One of the more interesting topics is the &lsquo;Grant Matcher&rsquo; puzzle and it&rsquo;s implications for what kinds of cooperation are possible. Here&rsquo;s the original full text of the problem, but I&rsquo;ll be restating it below.
The Phantom Menace First a quick Object Capabilities (OCap) primer, if you know what OCap is just skip to the next section."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://mikayla-maki.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "The Implications of the Grant Matcher Puzzle",
      "item": "https://mikayla-maki.github.io/posts/grant-matcher/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "The Implications of the Grant Matcher Puzzle",
  "name": "The Implications of the Grant Matcher Puzzle",
  "description": "I\u0026rsquo;ve been getting into Object Capabilites recently and it\u0026rsquo;s been immense fun finding people solving all the same problems I\u0026rsquo;ve been thinking about for the last year. One of the more interesting topics is the \u0026lsquo;Grant Matcher\u0026rsquo; puzzle and it\u0026rsquo;s implications for what kinds of cooperation are possible. Here\u0026rsquo;s the original full text of the problem, but I\u0026rsquo;ll be restating it below.\nThe Phantom Menace First a quick Object Capabilities (OCap) primer, if you know what OCap is just skip to the next section.",
  "keywords": [
    
  ],
  "articleBody": "I’ve been getting into Object Capabilites recently and it’s been immense fun finding people solving all the same problems I’ve been thinking about for the last year. One of the more interesting topics is the ‘Grant Matcher’ puzzle and it’s implications for what kinds of cooperation are possible. Here’s the original full text of the problem, but I’ll be restating it below.\nThe Phantom Menace First a quick Object Capabilities (OCap) primer, if you know what OCap is just skip to the next section. Object Capabilities encode authority into object references. Having a reference to an Object is equivalent to having the authority to access that object in all ways that this object allows. Contrast this with the more typical Access Control List (ACL) model, where it’s possible to maintain a reference to something but not have permissions to access it. It’s a bit like the difference between file descriptors, and file names with associated permissions. If you have a file descriptor, you know that someone, at some point, had the authority to open this file, and now you can do whatever this file descriptor is allowed to do (Append only, read only, read and write, etc.). Crucially, your code never had to worry about how this file descriptor is created, all of that complexity is encapsulated by the presence of the file descriptor. Contrast this with handing around file names. Names require that all parts of your codebase share the same file namespace (unlikely in distributed systems) and the presence of a filename doesn’t provide any information about whether this code can (or should) be accessing it. Using file names instead of descriptors breaks encapsulation by forcing all of your code to deal with this complexity, every time.\nOne of the core benefits of capability references, and the one relevant to the Grant Matcher puzzle, is that they can be composed with Objects to create new behavior. One way this can happen is attentuation, making a capability ‘smaller’ before handing it on. Taking the file descriptor example above, imagine being given a ‘read-write’ file descriptor, and being able to wrap it in a ‘read-only’ handle that you then pass to another part of the system. Another way is through transparent references, which allow you to augment your existing capabilities with new behaviors. Again with file descriptors, it’s like being able to wrap a file descriptor with a boolean that revokes access to the file, while still appearing to be a plain file descriptor to whoever you’re handing it to. The Grant Matcher puzzle puts these benefits to the test.\nAttack of the Grant Matcher Puzzle Let’s imagine a world with the following Objects:\n A Charity Alice Bob A Grant Matcher  The Grant Matcher’s job is simple: Check if both Alice and Bob donated $10 to it. If they both did, send their combined money ($20) to the Charity. If they didn’t, refund their money. Alice and Bob do not trust each other but they do trust the Grant Matcher to perform it’s duties. Finally, Alice and Bob both have a reference to the Grant Matcher and a reference to the charity. Here’s a diagram of the setup:\n  Black, thin arrows denote references, circles denote objects. Access is authority in Object Capabilities, so both Alice and Bob can talk to the grant matcher and the Charity, but not to each other.\n  Here’s how it should go, Alice and Bob send the Grant Matcher their cash, the grant matcher checks that their donations match, and the grant matcher sends their money on:\n  First, Alice sends $10 to the Grant Matcher. Then Bob sends $10 to the Grant Matcher. Then the Grant Matcher donates their $20 to the Charity\n  But there’s a problem with this picture: messages can only be sent when there’s a reference to an Object, and according to the setup to this puzzle the Grant Matcher doesn’t have a reference to the Charity. Let’s fix this by adding references to the messages that Alice and Bob send:\n  First, Alice now sends $10 to the Grant Matcher and a reference to the charity. Then Bob sends $10 to the Grant Matcher and a reference to the charity.\n  But here’s the crux of the problem: how does the grant matcher know if these references are equal? To preserve referential transparency, the Grant Matcher must ask both references for their identity. Alice can use this fact to insert a reference to a Fake Charity:\n  Alice now sends $10 to the Grant Matcher and a reference to a Fake Charity object. Then Bob sends $10 to the Grant Matcher and a reference to the real charity. The grant matcher then sends a message to both the fake and real charity asking for their identity. The fake charity forwards this message on to the real Charity\n  When the Grant Matcher tries to ask for the charity ID, Alice’s Fake Charity can forward the message on to the real charity, and then return the results to the grant matcher:\n  The same image as before, but now annotated with the response from the Charity, ‘KEQD’, going to both the Grant Matcher and the Fake Charity. The Fake Charity then returns the same identifier, ‘KEQD’, to the Grant Matcher. The grant matcher then thinks ‘Both references say they’re the same thing, great! These references must match.’\n  The grant matcher then picks Alice’s reference to send the donation on and Alice’s fake charity sees that this message has the money on it, and instead sends it to Alice!\n  The grant matcher sends a message to donate $20 to Alice’s fake charity, and the fake charity forwards that Message to Alice, successfully stealing Bob’s money\n  So we’re at an impasse. Capabilities require referential transparency to provide their value, but referential transparency creates a serious security problem.\nRevenge of the Reference Equality Operator From what I’ve learned, there are two standard solutions to this problem:\nThe first solution preserves referential transparency by having Alice and Bob each send the grant matcher a seperate ‘sealer’ along with their money and charity reference. Sealers allow their users to wrap an Object in a box that only the corresponding unsealer can unwrap. The Grant Matcher would use the two sealers that Alice and Bob provide to double-wrap the money and the Charity would hold the corresponding unsealers to unwrap the money. Two important notes, first that this solution requires that Alice and Bob trust the Charity to behave properly, which violates the setup of the Puzzle. Secondly, this doesn’t actually solve the grant matcher puzzle, if Alice doesn’t mind losing $10 she can still launch the same attack and take Bob’s $10.\nThe second solution abandons referential transparency by requiring that Bob and Alice have the exact same reference, and thus the exact same authority, to the Charity in order to use the Grant Matcher. This does correctly solve the problem, there’s no way for Bob to lose his $10 now, but it’s such a huge restriction that it makes the Grant Matcher worthless. The Grant Matcher is supposed to solve a coordination problem by providing the trust that Alice and Bob need to complete their matching grant. If they’re coordinating to synchronize their references, why do they need the Grant Matcher at all? And how are they going to agree on which of their two references to use if they don’t trust each other? We could solve this by adding a condition to the puzzle that Alice and Bob’s references are the same, but this trivializes the whole problem into uselessness.\nSo neither of these solutions are good enough, what can we do about it?\nA New Hope Let’s take a step back, why does this problem exist at all? I propose that, in the setup of the Grant Matcher puzzle, there is a violation of the Principle of Least Authority that causes all of these issues. Let’s go back to that successful grant match diagram:\n  First, Alice sends $10 to the Grant Matcher. Then Bob sends $10 to the Grant Matcher. Then the Grant Matcher donates their $20 to the Charity\n  The problem with this situation was that, according to the puzzle setup, the Grant Matcher doesn’t know about the Charity. Because it doesn’t know about the charity, the Grant Matcher must be given both the authority to check matching donations, as well as the authority to resolve the two references into a single ‘true reference’. It’s this second authority which breaks encapsulation, forces the Grant Matcher to use a raw reference equality check, and make Alice and Bob unable to cooperate safely.\nSo let’s break that second authority out and see what happens. In order for the Grant Matcher to know where to donate the money, it needs to be created with a trusted reference to the correct Charity to donate to. If Alice and Bob don’t trust each other, or each other’s references, the only entity which can provide a trusted reference to the Charity is the Charity itself. This requires that Alice and Bob trust the Charity to behave correctly. Note that the original puzzle statement explicitly removes the possibility of trusting the Charity:\n “The Grant Matcher pattern, however, is supposed to bring about a particular kind of cooperation between Alice and Dana, requiring only that they both trust the Grant Matcher and a common monetary system.” Emphasis added. From erights.org\n However, the sealer/unsealer pair solution to the Grant Matcher puzzle requires a trustworthy Charity, and further I can’t conceive of a scenario where Alice and Bob both trust the Charity with their money, but don’t trust it to behave correctly (ignoring technical glitches). Given these two statements, I consider adding a trustworthy Charity to the initial conditions to be an acceptable modification to the rules of the puzzle.\nBack to the puzzle, let’s start from the beginning with this insight. Intially there are only Alice, Bob, and a Charity. Alice and Bob use their references to the Charity to ask the Charity to create a grant matcher. The Charity gives them back references to a Grant Matcher that the Charity has initialized with a reference back to the Charity:\n  In this new initial state, Alice and Bob both ask the Charity for a new Grant Matcher. The Charity instantiates a Grant Matcher with a reference to the charity, a ‘Charity Matcher’\n  Now there isn’t even a puzzle. Alice and Bob can’t forward references to the Grant Matcher (it only cares about their money) and so Alice can’t launch her attack on the Grant Matcher. This also preserves referential transparency, as Alice and Bob’s references to the Charity, and their references to the Grant Matcher, can be behind as many different kinds of references as they please. All that matters is that the Charity is capable of receiving Alice and Bob’s messages, is capable of giving them a reference to the new grant matcher, and the Grant Matcher is eventually capable of being called twice with Alice and Bob’s money.\nSuccess! We’ve eliminated reference equality checks! Or have we?\nThe Reference Equality Operator Strikes Back An issue I glossed over above is that the Charity must somehow know who to send which references. We can imagine a scenario where there are thousands of people all simultaneously starting and resolving Grant Matcher sessions on this Charity. The Charity will need some identifier associated with both Alice and Bob which uniquely identifies their session. There are at least two different ways this could work:\n  Name-based. Alice provides a name for Bob when requesting a session: ‘Start Grant Matcher with Bob, from Alice’. Bob sends the reverse message: ‘Start Grant Matcher with Alice, from Bob’. The Charity compares these two messages, notices the matching names, and resolves the sessions by giving Alice and Bob their Grant Matcher\n  ID-based. Alice sends a ‘Start Grant Matcher Session’ message to the charity. The charity returns a session ID to Alice. Alice hands this session ID to Bob and Bob sends a ‘Join Grant Matcher Session with ID’ to the charity.\n  The name based solution does not require communication between Alice and Bob, but does require that they both have out of band information. Alice must be able to refer to Bob, and Bob to Alice, without actually having a proper reference to each other. They do this by falling back onto a global namespace of human-readable names produced from somewhere outside of our system of Objects and references. This requires bundling in all of the complexity of matching human names into the Charity. These human-readable names can be thought of as a ‘raw reference’, something carrying the capacity to refer without all of the behavior of a proper OCap reference.\nNote that this name-based solution is similar to the original reference equality solution. Both rely on falling back to a shared namespace and to disambiguate a referal. For the reference equality solution, that shared namespace is the programming language’s reference system and the disambiguation is reference equality.\nThe ID based solution requires Bob and Alice to be in some kind of communication, but does not require any out of band information or even an external namespace. The Charity encapsulates every possible session ID and so can do a fast and cheap bitwise comparison. If we allow Alice and Bob’s communication to be in-band via a normal OCap reference, we can even hide the existence of these session IDs entirely, with a protocol like so:\n  A diagram of the 4 states of the system between Alice initiating a grant matcher session and Bob joining it. Alice and Bob both have a reference to Charity and Alice has a Reference to Bob. Alice asks the charity for a session key. Alice receives a promise for a Grant Matcher and a reference to the session key. Alice then sends a reference to this session key to Bob. Bob redeems his session key with the Charity for a reference the now resolved Grant Matcher.\n  We could also imagine a similar kind of protocol that provides a name resolution service for the Charity, that similarly wraps up raw name references into Objects.\nNote that, just like the original two solutions, both of these new solutions require that either Alice and Bob have some shared out of band information, or that Alice and Bob coordinate directly to create their Grant Matcher. The Grant Matcher puzzle is simply impossible to solve perfectly without one of these two changes. It is possible to solve imperfectly though, with the sealer/unsealer method.\nThe Return of Reference Equality Once the Grant Matcher Object is adjusted to reduce it’s authority, the puzzle is revealed to really be asking Alice and Bob to refer to each other without actually having a reference to each other. This violates the entire premise of OCap but is quite common and useful in the real world. Imagine Bob and Alice met on twitter, and want to match their grants, but their OCap systems have never communicated before. Before Alice and Bob can communicate at all, they need to bootstrap their capabality systems by establishing a mutually trusted namespace and exchanging raw references within this namespace. Thankfully, OCap is more than capable of modeling this complexity, as the session keys example shows. We can have our referential transparency cake and eat our reference equality cake too. We may never be rid of a reference equality operator, but at least we don’t need to use the reference equality operator to cooperate.\n",
  "wordCount" : "2578",
  "inLanguage": "en",
  "datePublished": "2022-08-21T15:15:00-07:00",
  "dateModified": "2022-08-21T15:15:00-07:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mikayla-maki.github.io/posts/grant-matcher/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mikayla's Project Updates",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mikayla-maki.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mikayla-maki.github.io/" accesskey="h" title="Mikayla&#39;s Project Updates (Alt + H)">Mikayla&#39;s Project Updates</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      The Implications of the Grant Matcher Puzzle
    </h1>
    <div class="post-meta"><span title='2022-08-21 15:15:00 -0700 PDT'>August 21, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>I&rsquo;ve been getting into Object Capabilites recently and it&rsquo;s been immense fun finding people solving all the same problems I&rsquo;ve been thinking about for the last year. One of the more interesting topics is the &lsquo;Grant Matcher&rsquo; puzzle and it&rsquo;s implications for what kinds of cooperation are possible. <a href="http://www.erights.org/elib/equality/grant-matcher/index.html">Here&rsquo;s the original full text of the problem</a>, but I&rsquo;ll be restating it below.</p>
<h3 id="the-phantom-menace">The Phantom Menace<a hidden class="anchor" aria-hidden="true" href="#the-phantom-menace">#</a></h3>
<p>First a quick Object Capabilities (OCap) primer, if you know what OCap is just skip to the next section. Object Capabilities encode authority into object references. Having a reference to an Object is equivalent to having the authority to access that object in all ways that this object allows. Contrast this with the more typical Access Control List (ACL) model, where it&rsquo;s possible to maintain a reference to something but not have permissions to access it. It&rsquo;s a bit like the difference between file descriptors, and file names with associated permissions. If you have a file descriptor, you know that someone, at some point, had the authority to open this file, and now you can do whatever this file descriptor is allowed to do (Append only, read only, read and write, etc.). Crucially, your code never had to worry about how this file descriptor is created, all of that complexity is encapsulated by the presence of the file descriptor. Contrast this with handing around file names. Names require that all parts of your codebase share the same file namespace (unlikely in distributed systems) and the presence of a filename doesn&rsquo;t provide any information about whether this code can (or should) be accessing it. Using file names instead of descriptors breaks encapsulation by forcing all of your code to deal with this complexity, every time.</p>
<p>One of the core benefits of capability references, and the one relevant to the Grant Matcher puzzle, is that they can be composed with Objects to create new behavior. One way this can happen is attentuation, making a capability &lsquo;smaller&rsquo; before handing it on. Taking the file descriptor example above, imagine being given a &lsquo;read-write&rsquo; file descriptor, and being able to wrap it in a &lsquo;read-only&rsquo; handle that you then pass to another part of the system. Another way is through transparent references, which allow you to augment your existing capabilities with new behaviors. Again with file descriptors, it&rsquo;s like being able to wrap a file descriptor with a boolean that revokes access to the file, while still appearing to be a plain file descriptor to whoever you&rsquo;re handing it to. The Grant Matcher puzzle puts these benefits to the test.</p>
<h3 id="attack-of-the-grant-matcher-puzzle">Attack of the Grant Matcher Puzzle<a hidden class="anchor" aria-hidden="true" href="#attack-of-the-grant-matcher-puzzle">#</a></h3>
<p>Let&rsquo;s imagine a world with the following Objects:</p>
<ul>
<li>A Charity</li>
<li>Alice</li>
<li>Bob</li>
<li>A Grant Matcher</li>
</ul>
<p>The Grant Matcher&rsquo;s job is simple: Check if both Alice and Bob donated $10 to it. If they both did, send their combined money ($20) to the Charity. If they didn&rsquo;t, refund their money. Alice and Bob do not trust each other but they do trust the Grant Matcher to perform it&rsquo;s duties. Finally, Alice and Bob both have a reference to the Grant Matcher and a reference to the charity. Here&rsquo;s a diagram of the setup:</p>
<figure>
    <img loading="lazy" src="/grant-matcher/initial.png"
         alt="Black, thin arrows denote references, circles denote objects. Access is authority in Object Capabilities, so both Alice and Bob can talk to the grant matcher and the Charity, but not to each other."/> <figcaption>
            <p>Black, thin arrows denote references, circles denote objects. Access is authority in Object Capabilities, so both Alice and Bob can talk to the grant matcher and the Charity, but not to each other.</p>
        </figcaption>
</figure>

<p>Here&rsquo;s how it should go, Alice and Bob send the Grant Matcher their cash, the grant matcher checks that their donations match, and the grant matcher sends their money on:</p>
<figure>
    <img loading="lazy" src="/grant-matcher/success.png"
         alt="First, Alice sends $10 to the Grant Matcher. Then Bob sends $10 to the Grant Matcher. Then the Grant Matcher donates their $20 to the Charity"/> <figcaption>
            <p>First, Alice sends $10 to the Grant Matcher. Then Bob sends $10 to the Grant Matcher. Then the Grant Matcher donates their $20 to the Charity</p>
        </figcaption>
</figure>

<p>But there&rsquo;s a problem with this picture: messages can only be sent when there&rsquo;s a reference to an Object, and according to the setup to this puzzle the Grant Matcher doesn&rsquo;t have a reference to the Charity. Let&rsquo;s fix this by adding references to the messages that Alice and Bob send:</p>
<figure>
    <img loading="lazy" src="/grant-matcher/refs.png"
         alt="First, Alice now sends $10 to the Grant Matcher and a reference to the charity. Then Bob sends $10 to the Grant Matcher and a reference to the charity."/> <figcaption>
            <p>First, Alice now sends $10 to the Grant Matcher and a reference to the charity. Then Bob sends $10 to the Grant Matcher and a reference to the charity.</p>
        </figcaption>
</figure>

<p>But here&rsquo;s the crux of the problem: how does the grant matcher know if these references are equal? To preserve referential transparency, the Grant Matcher must ask both references for their identity. Alice can use this fact to insert a reference to a Fake Charity:</p>
<figure>
    <img loading="lazy" src="/grant-matcher/fake-attack.png"
         alt="Alice now sends $10 to the Grant Matcher and a reference to a Fake Charity object. Then Bob sends $10 to the Grant Matcher and a reference to the real charity. The grant matcher then sends a message to both the fake and real charity asking for their identity. The fake charity forwards this message on to the real Charity"/> <figcaption>
            <p>Alice now sends $10 to the Grant Matcher and a reference to a Fake Charity object. Then Bob sends $10 to the Grant Matcher and a reference to the real charity. The grant matcher then sends a message to both the fake and real charity asking for their identity. The fake charity forwards this message on to the real Charity</p>
        </figcaption>
</figure>

<p>When the Grant Matcher tries to ask for the charity ID, Alice&rsquo;s Fake Charity can forward the message on to the real charity, and then return the results to the grant matcher:</p>
<figure>
    <img loading="lazy" src="/grant-matcher/message-forwarding.png"
         alt="The same image as before, but now annotated with the response from the Charity, &amp;lsquo;KEQD&amp;rsquo;, going to both the Grant Matcher and the Fake Charity. The Fake Charity then returns the same identifier, &amp;lsquo;KEQD&amp;rsquo;, to the Grant Matcher. The grant matcher then thinks &amp;lsquo;Both references say they&amp;rsquo;re the same thing, great! These references must match.&amp;rsquo;"/> <figcaption>
            <p>The same image as before, but now annotated with the response from the Charity, &lsquo;KEQD&rsquo;, going to both the Grant Matcher and the Fake Charity. The Fake Charity then returns the same identifier, &lsquo;KEQD&rsquo;, to the Grant Matcher. The grant matcher then thinks &lsquo;Both references say they&rsquo;re the same thing, great! These references must match.&rsquo;</p>
        </figcaption>
</figure>

<p>The grant matcher then picks Alice&rsquo;s reference to send the donation on and Alice&rsquo;s fake charity sees that this message has the money on it, and instead sends it to Alice!</p>
<figure>
    <img loading="lazy" src="/grant-matcher/fake-steals.png"
         alt="The grant matcher sends a message to donate $20 to Alice&amp;rsquo;s fake charity, and the fake charity forwards that Message to Alice, successfully stealing Bob&amp;rsquo;s money"/> <figcaption>
            <p>The grant matcher sends a message to donate $20 to Alice&rsquo;s fake charity, and the fake charity forwards that Message to Alice, successfully stealing Bob&rsquo;s money</p>
        </figcaption>
</figure>

<p>So we&rsquo;re at an impasse. Capabilities require referential transparency to provide their value, but referential transparency creates a serious security problem.</p>
<h3 id="revenge-of-the-reference-equality-operator">Revenge of the Reference Equality Operator<a hidden class="anchor" aria-hidden="true" href="#revenge-of-the-reference-equality-operator">#</a></h3>
<p>From what I&rsquo;ve learned, there are two standard solutions to this problem:</p>
<p>The first solution preserves referential transparency by having Alice and Bob each send the grant matcher a seperate &lsquo;sealer&rsquo; along with their money and charity reference. Sealers allow their users to wrap an Object in a box that only the corresponding unsealer can unwrap. The Grant Matcher would use the two sealers that Alice and Bob provide to double-wrap the money and the Charity would hold the corresponding unsealers to unwrap the money. Two important notes, first that this solution requires that Alice and Bob trust the Charity to behave properly, which violates the setup of the Puzzle. Secondly, this doesn&rsquo;t actually solve the grant matcher puzzle, if Alice doesn&rsquo;t mind losing $10 she can still launch the same attack and take Bob&rsquo;s $10.</p>
<p>The second solution abandons referential transparency by requiring that Bob and Alice have the exact same reference, and thus the exact same authority, to the Charity in order to use the Grant Matcher. This does correctly solve the problem, there&rsquo;s no way for Bob to lose his $10 now, but it&rsquo;s such a huge restriction that it makes the Grant Matcher worthless. The Grant Matcher is supposed to solve a coordination problem by providing the trust that Alice and Bob need to complete their matching grant. If they&rsquo;re coordinating to synchronize their references, why do they need the Grant Matcher at all? And how are they going to agree on which of their two references to use if they don&rsquo;t trust each other? We could solve this by adding a condition to the puzzle that Alice and Bob&rsquo;s references are the same, but this trivializes the whole problem into uselessness.</p>
<p>So neither of these solutions are good enough, what can we do about it?</p>
<h3 id="a-new-hope">A New Hope<a hidden class="anchor" aria-hidden="true" href="#a-new-hope">#</a></h3>
<p>Let&rsquo;s take a step back, why does this problem exist at all? I propose that, in the setup of the Grant Matcher puzzle, there is a violation of the Principle of Least Authority that causes all of these issues. Let&rsquo;s go back to that successful grant match diagram:</p>
<figure>
    <img loading="lazy" src="/grant-matcher/success.png"
         alt="First, Alice sends $10 to the Grant Matcher. Then Bob sends $10 to the Grant Matcher. Then the Grant Matcher donates their $20 to the Charity"/> <figcaption>
            <p>First, Alice sends $10 to the Grant Matcher. Then Bob sends $10 to the Grant Matcher. Then the Grant Matcher donates their $20 to the Charity</p>
        </figcaption>
</figure>

<p>The problem with this situation was that, according to the puzzle setup, the Grant Matcher doesn&rsquo;t know about the Charity. Because it doesn&rsquo;t know about the charity, the Grant Matcher must be given both the authority to check matching donations, as well as the authority to resolve the two references into a single &lsquo;true reference&rsquo;. It&rsquo;s this second authority which breaks encapsulation, forces the Grant Matcher to use a raw reference equality check, and make Alice and Bob unable to cooperate safely.</p>
<p>So let&rsquo;s break that second authority out and see what happens. In order for the Grant Matcher to know where to donate the money, it needs to be created with a trusted reference to the correct Charity to donate to. If Alice and Bob don&rsquo;t trust each other, or each other&rsquo;s references, the only entity which can provide a trusted reference to the Charity is the Charity itself. This requires that Alice and Bob trust the Charity to behave correctly. Note that the original puzzle statement explicitly removes the possibility of trusting the Charity:</p>
<blockquote>
<p>&ldquo;The Grant Matcher pattern, however, is supposed to bring about a particular kind of cooperation between Alice and Dana, requiring <strong>only</strong> that they both trust the Grant Matcher and a common monetary system.&rdquo; Emphasis added. <a href="http://www.erights.org/elib/equality/grant-matcher/index.html">From erights.org</a></p>
</blockquote>
<p>However, the sealer/unsealer pair solution to the Grant Matcher puzzle requires a trustworthy Charity, and further I can&rsquo;t conceive of a scenario where Alice and Bob both trust the Charity with their money, but don&rsquo;t trust it to behave correctly (ignoring technical glitches). Given these two statements, I consider adding a trustworthy Charity to the initial conditions to be an acceptable modification to the rules of the puzzle.</p>
<p>Back to the puzzle, let&rsquo;s start from the beginning with this insight. Intially there are only Alice, Bob, and a Charity. Alice and Bob use their references to the Charity to ask the Charity to create a grant matcher. The Charity gives them back references to a Grant Matcher that the Charity has initialized with a reference back to the Charity:</p>
<figure>
    <img loading="lazy" src="/grant-matcher/new-initial.png"
         alt="In this new initial state, Alice and Bob both ask the Charity for a new Grant Matcher. The Charity instantiates a Grant Matcher with a reference to the charity, a &amp;lsquo;Charity Matcher&amp;rsquo;"/> <figcaption>
            <p>In this new initial state, Alice and Bob both ask the Charity for a new Grant Matcher. The Charity instantiates a Grant Matcher with a reference to the charity, a &lsquo;Charity Matcher&rsquo;</p>
        </figcaption>
</figure>

<p>Now there isn&rsquo;t even a puzzle. Alice and Bob can&rsquo;t forward references to the Grant Matcher (it only cares about their money) and so Alice can&rsquo;t launch her attack on the Grant Matcher. This also preserves referential transparency, as Alice and Bob&rsquo;s references to the Charity, and their references to the Grant Matcher, can be behind as many different kinds of references as they please. All that matters is that the Charity is capable of receiving Alice and Bob&rsquo;s messages, is capable of giving them a reference to the new grant matcher, and the Grant Matcher is eventually capable of being called twice with Alice and Bob&rsquo;s money.</p>
<p>Success! We&rsquo;ve eliminated reference equality checks! Or have we?</p>
<h3 id="the-reference-equality-operator-strikes-back">The Reference Equality Operator Strikes Back<a hidden class="anchor" aria-hidden="true" href="#the-reference-equality-operator-strikes-back">#</a></h3>
<p>An issue I glossed over above is that the Charity must somehow know who to send which references. We can imagine a scenario where there are thousands of people all simultaneously starting and resolving Grant Matcher sessions on this Charity. The Charity will need some identifier associated with both Alice and Bob which uniquely identifies their session. There are at least two different ways this could work:</p>
<ol>
<li>
<p>Name-based. Alice provides a name for Bob when requesting a session: &lsquo;Start Grant Matcher with Bob, from Alice&rsquo;. Bob sends the reverse message: &lsquo;Start Grant Matcher with Alice, from Bob&rsquo;. The Charity compares these two messages, notices the matching names, and resolves the sessions by giving Alice and Bob their Grant Matcher</p>
</li>
<li>
<p>ID-based. Alice sends a &lsquo;Start Grant Matcher Session&rsquo; message to the charity. The charity returns a session ID to Alice. Alice hands this session ID to Bob and Bob sends a &lsquo;Join Grant Matcher Session with ID&rsquo; to the charity.</p>
</li>
</ol>
<p>The name based solution does not require communication between Alice and Bob, but does require that they both have out of band information. Alice must be able to refer to Bob, and Bob to Alice, without actually having a proper reference to each other. They do this by falling back onto a global namespace of human-readable names produced from somewhere outside of our system of Objects and references. This requires bundling in all of the complexity of matching human names into the Charity. These human-readable names can be thought of as a &lsquo;raw reference&rsquo;, something carrying the capacity to refer without all of the behavior of a proper OCap reference.</p>
<p>Note that this name-based solution is similar to the original reference equality solution. Both rely on falling back to a shared namespace and to disambiguate a referal. For the reference equality solution, that shared namespace is the programming language&rsquo;s reference system and the disambiguation is reference equality.</p>
<p>The ID based solution requires Bob and Alice to be in some kind of communication, but does not require any out of band information or even an external namespace. The Charity encapsulates every possible session ID and so can do a fast and cheap bitwise comparison. If we allow Alice and Bob&rsquo;s communication to be in-band via a normal OCap reference, we can even hide the existence of these session IDs entirely, with a protocol like so:</p>
<figure>
    <img loading="lazy" src="/grant-matcher/non-raw-reference.png"
         alt="A diagram of the 4 states of the system between Alice initiating a grant matcher session and Bob joining it. Alice and Bob both have a reference to Charity and Alice has a Reference to Bob. Alice asks the charity for a session key. Alice receives a promise for a Grant Matcher and a reference to the session key. Alice then sends a reference to this session key to Bob. Bob redeems his session key with the Charity for a reference the now resolved Grant Matcher."/> <figcaption>
            <p>A diagram of the 4 states of the system between Alice initiating a grant matcher session and Bob joining it. Alice and Bob both have a reference to Charity and Alice has a Reference to Bob. Alice asks the charity for a session key. Alice receives a promise for a Grant Matcher and a reference to the session key. Alice then sends a reference to this session key to Bob. Bob redeems his session key with the Charity for a reference the now resolved Grant Matcher.</p>
        </figcaption>
</figure>

<p>We could also imagine a similar kind of protocol that provides a name resolution service for the Charity, that similarly wraps up raw name references into Objects.</p>
<p>Note that, just like the original two solutions, both of these new solutions require that either Alice and Bob have some shared out of band information, or that Alice and Bob coordinate directly to create their Grant Matcher. The Grant Matcher puzzle is simply impossible to solve perfectly without one of these two changes. It is possible to solve imperfectly though, with the sealer/unsealer method.</p>
<h3 id="the-return-of-reference-equality">The Return of Reference Equality<a hidden class="anchor" aria-hidden="true" href="#the-return-of-reference-equality">#</a></h3>
<p>Once the Grant Matcher Object is adjusted to reduce it&rsquo;s authority, the puzzle is revealed to really be asking Alice and Bob to refer to each other without actually having a reference to each other. This violates the entire premise of OCap but is quite common and useful in the real world. Imagine Bob and Alice met on twitter, and want to match their grants, but their OCap systems have never communicated before. Before Alice and Bob can communicate at all, they need to bootstrap their capabality systems by establishing a mutually trusted namespace and exchanging raw references within this namespace.  Thankfully, OCap is more than capable of modeling this complexity, as the session keys example shows. We can have our referential transparency cake and eat our reference equality cake too. We may never be rid of <em>a</em> reference equality operator, but at least we don&rsquo;t need to use <em>the</em> reference equality operator to cooperate.</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://mikayla-maki.github.io/">Mikayla&#39;s Project Updates</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
