<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>P2P Browser | Mikayla&#39;s Project Updates</title>
<meta name="keywords" content="" />
<meta name="description" content="Assumptions: (what is this?)
 Client-server architecture needs to be replaced by P2P  I&rsquo;ve been seeing a lot of talk from smart people about how to do a p2p internet properly, and I want to throw my own architecture proposal into the ring. My goal is to surpass the ease of use and accessibility of modern social media apps, while also structurally distributing power to users (also referred to as &lsquo;peers&rsquo;).">
<meta name="author" content="">
<link rel="canonical" href="https://mikayla-maki.github.io/posts/p2p-browser/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css" integrity="sha256-b2AFbUTT9&#43;tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mikayla-maki.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mikayla-maki.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mikayla-maki.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mikayla-maki.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://mikayla-maki.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.2" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="P2P Browser" />
<meta property="og:description" content="Assumptions: (what is this?)
 Client-server architecture needs to be replaced by P2P  I&rsquo;ve been seeing a lot of talk from smart people about how to do a p2p internet properly, and I want to throw my own architecture proposal into the ring. My goal is to surpass the ease of use and accessibility of modern social media apps, while also structurally distributing power to users (also referred to as &lsquo;peers&rsquo;)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mikayla-maki.github.io/posts/p2p-browser/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-22T15:04:11-08:00" />
<meta property="article:modified_time" content="2022-01-22T15:04:11-08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="P2P Browser"/>
<meta name="twitter:description" content="Assumptions: (what is this?)
 Client-server architecture needs to be replaced by P2P  I&rsquo;ve been seeing a lot of talk from smart people about how to do a p2p internet properly, and I want to throw my own architecture proposal into the ring. My goal is to surpass the ease of use and accessibility of modern social media apps, while also structurally distributing power to users (also referred to as &lsquo;peers&rsquo;)."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://mikayla-maki.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "P2P Browser",
      "item": "https://mikayla-maki.github.io/posts/p2p-browser/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "P2P Browser",
  "name": "P2P Browser",
  "description": "Assumptions: (what is this?)\n Client-server architecture needs to be replaced by P2P  I\u0026rsquo;ve been seeing a lot of talk from smart people about how to do a p2p internet properly, and I want to throw my own architecture proposal into the ring. My goal is to surpass the ease of use and accessibility of modern social media apps, while also structurally distributing power to users (also referred to as \u0026lsquo;peers\u0026rsquo;).",
  "keywords": [
    
  ],
  "articleBody": "Assumptions: (what is this?)\n Client-server architecture needs to be replaced by P2P  I’ve been seeing a lot of talk from smart people about how to do a p2p internet properly, and I want to throw my own architecture proposal into the ring. My goal is to surpass the ease of use and accessibility of modern social media apps, while also structurally distributing power to users (also referred to as ‘peers’).\nThere are some patterns of problems that I see in these (and other) discussions:\n Identity needs to be handled off-app. Twitter should not own my identity token, and neither should anyone else. Once identity is freed from the corporate ecosystems, we can create all kinds of communal filtering and processing functionality on a per-peer basis. But we have to get it out first. Virtual networks should be effortless to create and switch with no personal data lost. Bits need to be on hard drives. If they’re not on your personal phone, laptop, or server, then they’re not really yours. All of this, and it needs to run small enough and fast enough that any android phone can be a fully functional peer.  Identity is the trickiest to think about, as everyone is concerned about controlling who has access to what identity, but I think this is actually the most trivial to solve. When I’m browsing the internet I don’t care who anyone ‘really’ is, all I care about is that I can identify their content. Usually they help me figure it out by linking their blog and building their reputation. Therefore, the only component you need for a fully functional identity system in a peer to peer context, is an asymmetric key generator. Asymmetric key generators allows you create a public and private key pair. Anyone who has the public key can verify that the private key was used to sign a message. This fulfills the reputation function that lies at the core of human to human identity. Using a generic public key generator as the atomic identity source also gives you features like alt accounts and identity changes for free, which I really appreciate as a trans person.\nThe virtual networks point is the one I have the least understanding about. This @rechelon thread has some interesting critiques of modern networking. My lack of understanding tends to drive me towards abstracting the underlying network topology, specifically for the purposes of replacing it at some later date. But I am unsure if that is falling into the exact problem described above. Regardless! My thinking is that networks are fundamentally zones of awareness. Any node in a network can talk to the other nodes in the network and can’t really talk to nodes outside the network (unless they’re a special node who is also on an internetwork network). The peer to peer way to create this mutual awareness over an arbitrary underlying topology is with a Distributed Hash Table (DHT). This DHT would take public keys and return (signed) addresses where the public key holder can be found. One of the goals is to make network creation and switching effortless, so new DHTs should be easy to join (via an invite link to solve the initial-peer discovery problem) and the software should enable the same machine to be a part of dozens of networks. This allows people a high degree of choice in how visible they are to others, even before activating the public key filtering mechanisms. And since public keys and networks are disconnected, filtering by public key works across networks by default.\nRight now, these DHTs would probably return IP addresses, but any address that the client understands how to communicate with should theoretically work. This brings us to the third point, bit localization. I believe that the DHT should serve the (signed) address to a file server that provides (signed) data relating to the given public key. This file server should support push and pull dynamics, e.g. subscriptions and requests and such, as the data on it is created and changed. I personally think the fundamental file type should be a CRDT of bit stream operations, but I haven’t gotten far enough into CRDT technology to tell yet. I call this component the ‘datastore’.\nAnd finally, the usability angle. This should all be done inside a browser, using a similar paradigm as the client side single page web app. A P2P browser would come with the key generation, file serving, and DHT engine built in. DHT connections would be initiated by a protocol mediated invite from the initial peer as well as any engine configuration data. A web app could then be deconstructed into three components: A UI, a file or directory format inside the datastore, and a sorting function over incoming data streams. Making a new twitter UI is as trivial as swapping out the HTML and JavaScript template files. The browser can expose an API to resolve public key references into actual data to minimize network chatter. Mesh network based moderation can be done through browser plugins, that allow communities to build collective block lists or trust webs, while also allowing any individuals to punch through the block lists whenever they want. It’s their client. They can configure and control it however they like.\nThe final issue is scalability and intermittent/faulty connectivity of p2p systems. Unreliable clients can be smoothed by augmenting the browser to also cache and serve any data it sees passing by. It’s much easier to scale a viral tweet if everyone retweeting it can also temporarily service requests for it. It would also be trivial to delegate file serving capacities under this system, as data is only valid if signed, getting an always-on node might be as simple as paying someone to host your data for you and issuing a signed IP address update to the DHT. If you don’t like what they do, it’s fine, as the data is already replicated on your local browser. Simply stop sending it to them. Running out of local storage space can be solved in the same way, simply delete the data off of the browser; optionally backing it up first. There are many more potential problems waiting in the wings, but these seem to be no more difficult than the problems already faced by much of the internet, except now people have the tools to solve them for themselves.\nThis is the sketch of the idea for how to restructure things while maintaining the performance and accessibility targets that are needed for this system to take match or best the current architecture. Work needs to be done to create the browser described here as well as the generic DHT protocols and engine. I also need to design and test an app under this paradigm and see if it works as well as it does in my head. Feedback, critique, and links to related projects are highly appreciated. I’d hate to waste time on this if it turns out it’s a bad idea.\n",
  "wordCount" : "1168",
  "inLanguage": "en",
  "datePublished": "2022-01-22T15:04:11-08:00",
  "dateModified": "2022-01-22T15:04:11-08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mikayla-maki.github.io/posts/p2p-browser/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mikayla's Project Updates",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mikayla-maki.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mikayla-maki.github.io/" accesskey="h" title="Mikayla&#39;s Project Updates (Alt + H)">Mikayla&#39;s Project Updates</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      P2P Browser
    </h1>
    <div class="post-meta"><span title='2022-01-22 15:04:11 -0800 PST'>January 22, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>Assumptions: <a href="https://mikayla-maki.github.io/posts/ms-idea-graph-format-specifier/">(what is this?)</a></p>
<ul>
<li>Client-server architecture needs to be replaced by P2P</li>
</ul>
<p>I&rsquo;ve been seeing a <a href="https://twitter.com/illegally_beka/status/1480286112299962370">lot</a>
<a href="https://www.inkandswitch.com/local-first/">of</a>
<a href="https://twitter.com/rechelon/status/1484423600933380098?s=20">talk</a> from smart people about how to do a p2p internet
properly, and I want to throw my own architecture proposal into the ring. My goal is to surpass the ease of use and
accessibility of modern social media apps, while also structurally distributing
power to users (also referred to as &lsquo;peers&rsquo;).</p>
<p>There are some patterns of problems that I see in these (and other) discussions:</p>
<ul>
<li>Identity needs to be handled off-app. Twitter should not own my identity token, and neither should
anyone else. Once identity is freed from the corporate ecosystems, we can create all kinds of communal
filtering and processing functionality on a per-peer basis. But we have to get it out first.</li>
<li>Virtual networks should be effortless to create and switch with no personal data lost.</li>
<li>Bits need to be on hard drives. If they&rsquo;re not on your personal phone, laptop, or server, then they&rsquo;re
not really yours.</li>
<li>All of this, and it needs to run small enough and fast enough that any android phone can be a fully
functional peer.</li>
</ul>
<p>Identity is the trickiest to think about, as everyone is concerned about controlling who has access to what
identity, but I think this is actually the most trivial to solve. When I&rsquo;m browsing the internet I don&rsquo;t care
who anyone &lsquo;really&rsquo; is, all I care about is that I can identify their content. Usually they help me figure it
out by linking their blog and building their reputation. Therefore, the only component you need for a fully functional
identity system in a peer to peer context, is an asymmetric key generator. Asymmetric key generators allows you create a public
and private key pair. Anyone who has the public key can verify that the private key was used to sign a message. This fulfills
the reputation function that lies at the core of human to human identity. Using a generic public key generator as the atomic
identity source also gives you features like alt accounts and identity changes for free, which I really appreciate as a
trans person.</p>
<p>The virtual networks point is the one I have the least understanding about. <a href="https://twitter.com/rechelon/status/1484423600933380098?s=20">This @rechelon thread has some interesting critiques
of modern networking</a>. My lack of understanding tends to
drive me towards abstracting the underlying network topology, specifically for the purposes of replacing it at some later date.
But I am unsure if that is falling into the exact problem described above. Regardless! My thinking is that networks are fundamentally zones of awareness.
Any node in a network can talk to the other nodes in the network and can&rsquo;t really talk to nodes outside the network
(unless they&rsquo;re a special node who is also on an internetwork network). The peer to peer way to create this mutual awareness over an
arbitrary underlying topology is with a Distributed Hash Table (DHT). This DHT would take public keys and return (signed) addresses
where the public key holder can be found. One of the goals is to make network creation and switching effortless, so new DHTs
should be easy to join (via an invite link to solve the initial-peer discovery problem) and the software should enable the same
machine to be a part of dozens of networks. This allows people a high degree of choice in how visible they are to others, even
before activating the public key filtering mechanisms. And since public keys and networks are disconnected, filtering by public key works
across networks by default.</p>
<p>Right now, these DHTs would probably return IP addresses, but any address that the client understands how to communicate with
should theoretically work. This brings us to the third point, bit localization. I believe that the DHT should serve the (signed) address
to a file server that provides (signed) data relating to the given public key. This file server should support push and pull
dynamics, e.g. subscriptions and requests and such, as the data on it is created and changed. I personally think the
fundamental file type should be a CRDT of bit stream operations, but
I haven&rsquo;t gotten far enough into CRDT technology to tell yet. I call this component the &lsquo;datastore&rsquo;.</p>
<p>And finally, the usability angle. This should all be done inside a browser, using a similar paradigm as the client side
single page web app. A P2P browser would come with the key generation, file serving, and DHT engine built in. DHT connections
would be initiated by a protocol mediated invite from the initial peer as well as any engine configuration data. A
web app could then be deconstructed into three components: A UI, a file or directory format inside the datastore, and a sorting function over incoming
data streams. Making a new twitter UI is as trivial as swapping out the HTML and JavaScript template files. The browser can expose
an API to resolve public key references into actual data to minimize network chatter. Mesh network based
moderation can be done through browser plugins, that allow communities to build collective block lists or trust webs,
while also allowing any individuals to punch through the block lists whenever they want. It&rsquo;s their client. They can configure
and control it however they like.</p>
<p>The final issue is scalability and intermittent/faulty connectivity of p2p systems. Unreliable clients can be
smoothed by augmenting the browser to also cache and serve any data it sees passing by. It&rsquo;s much easier to scale a viral
tweet if everyone retweeting it can also temporarily service requests for it. It would also be trivial to delegate file
serving capacities under this system, as data is only valid if signed, getting an always-on node might be as simple as
paying someone to host your data for you and issuing a signed IP address update to the DHT. If you don&rsquo;t like what they do,
it&rsquo;s fine, as the data is already replicated on your local browser. Simply stop sending it to them. Running out of local
storage space can be solved in the same way, simply delete the data off of the browser; optionally backing it up first.
There are many more potential problems waiting in the wings, but these seem to be no more difficult than the
problems already faced by much of the internet, except now people have the tools to solve them for themselves.</p>
<p>This is the sketch of the idea for how to restructure things while maintaining the performance and accessibility targets that
are needed for this system to take match or best the current architecture.
Work needs to be done to create the browser described here as well as the generic DHT protocols and engine. I also
need to design and test an app under this paradigm and see if it works as well as it does in my head. Feedback, critique,
and links to related projects are highly appreciated. I&rsquo;d hate to waste time on this if it turns out it&rsquo;s a bad idea.</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://mikayla-maki.github.io/">Mikayla&#39;s Project Updates</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
